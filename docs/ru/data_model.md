# Модель данных

Архитектура SciCMS Core предполагает хранение метаданных (всей информации, необходимой для работы системы) в основной реляционной базе данных (встроенный источник данных `main`).
Для повышения производительности и обеспечения масштабируемости в облачном окружении метаданные кэшируются через [Redis](https://redis.io).

Остальные данные могут храниться как в основной, так и в любой другой БД.
Система позволяет подключать неограниченное число БД динамически в процессе работы.
При этом фактические подключения открываются только в момент обращения к базе, не расходуя ресурсы на простаивающие соединения.
При долгом простое (настраивается параметром `scicms-core.data.datasource-cache-expiration-minutes`) соединения закрываются, освобождая ресурсы системы.
В настоящий момент поддерживается СУБД PostgreSQL и Oracle.
В последующих версиях SciCMS Core с целью упрощения локального запуска планируется добавить возможность работы приложения со встроенной БД SQLite и кэшем в собственной памяти.
Также при необходимости будет добавляться поддержка других видов СУБД.
Процесс создания дополнительных источников данных будет рассмотрен далее в текущем разделе.

## Сущности
Центральным понятием в SciCMS Core является **сущность** (Item).
В аналогии с объектно-ориентированным программированием сущность представляет собой класс (описание полей и методов), а запись для данной сущности - экземпляр класса (конкретные данные).
Элементы метаданных также представляют собой предопределенные сущности. Сущность может быть создана тремя способами.

**Первый способ** - это создание декларативного определения сущности в YAML (или JSON) файле (например, `book-item.yml`).
Это определение по назначению и структуре очень похоже на манифесты в экосистеме [Kubernetes](https://kubernetes.io/).
Пример определения сущности в SciCMS Core:
```yaml
# book
coreVersion: v1
kind: Item
includeTemplates:
  - default
metadata:
  name: book
  displayName: Book
  pluralName: books
  displayPluralName: Books
  dataSource: main
  tableName: books
  description: Books
  performDdl: true
spec:
  attributes:
    name:
      type: string
      columnName: name
      displayName: Name
      description: Name
      required: true
      unique: true
      length: 50
    rating:
      type: int
      columnName: rating
      displayName: Rating
      description: Rating
      minRange: 0
      maxRange: 10
```

Полное описание всех полей находится в файле [model.schema.json](/src/main/resources/schema/model.schema.json).
В примере выше описывается сущность с именем `book`, которая включает в себя следующие поля:
- `coreVersion` - версия API SciCMS Core;
- `kind` - тип сущности (в настоящий момент поддерживаемые типы - `Item` и `ItemTemplate`);
- `includeTemplates` - включаемые шаблоны (шаблоны содержат набор предопределенных атрибутов);
- `metadata` - блок с метаданными сущности;
- `metadata.name` - имя сущности (латиницей без пробелов, используется при генерации методов API GraphQL);
- `metadata.displayName` - отображаемое имя сущности;
- `metadata.pluralName` - имя сущности во множественном числе (латиницей без пробелов, используется при генерации методов API GraphQL);
- `metadata.displayPluralName` - отображаемое имя сущности во множественном числе;
- `metadata.dataSource` - имя источника данных;
- `metadata.tableName` - имя таблицы в базе данных; не всем сущностям соответствуют таблицы в БД; есть сущности "только для чтения", которые вместо `tableName` имеют флаг `readOnly` = `true` и свойство `query` с произвольным SQL-запросом на выборку данных;
- `metadata.description` - описание сущности (используется при генерации документации для типов в API GraphQL);
- `metadata.performDdl` - флаг выполнения операций DDL в базе данных при создании/изменении сущности (CREATE/ALTER TABLE);
- `spec` - блок со спецификацией атрибутов и индексов сущности;
- `spec.attributes` - атрибуты сущности.

Каждая сущность имеет необязательный параметр `metadata.cacheTtl` - время жизни кэша в минутах.
Если он не задан, то принимается значение по умолчанию, равное 10 минут (параметр `scicms-core.data.item-query-result-entry-ttl-minutes` в файле [application.yml](/src/main/resources/application.yml)).
Если значение кэша меньше или равно 0, то записи сущности не кэшируются.
Кэш работает только для операций чтения. При изменении/удалении сущности кэш обновляется.
Если в настройках параметр `scicms-core.schema.clear-cache-on-seed` равен `true` (значение по умолчанию), то приложение сбрасывает кэш при каждом перезапуске.
Кэш также сбрасывается при выполнении операций над системными сущностями (у которых поле `metadata.core` равно `true`), такими как `item`, `user`, `group`, `permission` и др.
По умолчанию для всех создаваемых сущностей поле `metadata.core` равно `false`.

В определении сущности каждый атрибут имеет уникальное имя (вводится также латиницей и без пробелов) и спецификацию.
Спецификация атрибута может включать разных набор полей в зависимости от типа атрибута. Часть полей обязательные, часть - нет.
Вот некоторые из полей:
- `spec.attributes.<attr_name>.type` - тип атрибута (см. ниже);
- `spec.attributes.<attr_name>.columnName` - имя столбца в БД;
- `spec.attributes.<attr_name>.displayName` - отображаемое имя атрибута;
- `spec.attributes.<attr_name>.description` - описание атрибута;
- `spec.attributes.<attr_name>.required` - флаг обязательности атрибута;
- `spec.attributes.<attr_name>.unique` - флаг уникальности атрибута в пределах таблицы БД;
- `spec.attributes.<attr_name>.length` - длина строки (для типа `string`);
- `spec.attributes.<attr_name>.minRange` - минимальное значение (для числовых типов);
- `spec.attributes.<attr_name>.maxRange` - максимальное значение (для числовых типов);

### Типы атрибутов

Система поддерживает следующие типы атрибутов:
- `uuid` - строка формата [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier);
- `string` - строка фиксированной длины; максимальная длина определяется полем `length` атрибута; для строкового атрибута также может быть задан параметр `pattern` - регулярное выражение, которому должна соответствовать строка;
- `text` - строка неограниченной длины;
- `enum` - строковое перечисление; для данного атрибута необходимо поле `enumSet` с перечнем допустимых значений;
- `sequence` - значение атрибута будет браться из последовательности; последовательность представляет собой отдельную сущность и включает такие атрибуты как начальное значение, префикс, суффикс, шаг, заполнитель, длина заполнения; для атрибута с типом `sequence` должен быть задан параметр `seqName`, который ссылается на имя существующей последовательности;
- `email` - строка адреса электронной почты;
- `password` - строка пароля, дополнительно может быть задано поле `encode` - для кодирования строки при сохранении в БД;
- `int` - целочисленный тип, дополнительно могут быть заданы поля `minRange` и `maxRange`;
- `long` - длинный целочисленный тип, дополнительно могут быть заданы поля `minRange` и `maxRange`;
- `float` - числовой тип с плавающей точкой, дополнительно могут быть заданы поля `minRange` и `maxRange`;
- `double` - числовой тип с плавающей точкой двойной точности, дополнительно могут быть заданы поля `minRange` и `maxRange`;
- `decimal` - тип для десятичного числа, дополнительно могут быть заданы поля `minRange`, `maxRange`, `precision` и `scale`;
- `date` - тип для хранения даты;
- `time` - тип для хранения времени;
- `datetime` - тип для хранения даты и времени (предполагается хранение в поле информации о временной зоне, если данный механизм поддерживается СУБД);
- `timestamp` - тип для хранения даты и времени;
- `bool` - логический тип;
- `array` - массив (список) значений, в БД хранится в текстовом поле в виде JSON-массива;
- `json` - JSON-объект, в БД хранится в текстовом поле;
- `media` - файл; в столбце хранится идентификатор, ссылающийся на сущность `media`. Подробнее см. в разделе [Работа с файлами](media.md);
- `relation` - связь с другой сущностью (см. ниже).

### Связи

Существует четыре типа связей: `oneToOne`, `manyToOne`, `oneToMany` и `manyToMany`. Этот тип задается в поле `relType` атрибута.
Вторым обязательным параметром атрибута типа `relation` является `target` - имя сущности, с которой осуществляется связь.

#### Связь oneToOne

Данный вид связи подразумевает, что в другой таблице существует единственная запись, на которую ссылается запись текущей сущности (в столбце атрибута с типом `relation` текущей сущности хранится идентификатор записи второй сущности).
В этом случае текущая сущность является "владельцем" связи. Сущности составляющие связь `oneToOne`, могут принадлежать разным источникам данных.
В примере ниже сущность `user` владеет связью с сущностью `userInfo` через одноименный атрибут (и собственный столбец `user_info_id`):
```yaml
# user
metadata:
  name: user
spec:
  attributes:
    userInfo:
      type: relation
      relType: oneToOne
      target: userInfo
      columnName: user_info_id
```

Атрибут `userInfo` ссылается на атрибут второй сущности, который указывается в ее параметре `metadata.idAttribute` (по умолчанию - `id`).
Это поведение можно переопределить, если добавить к атрибуту связи поле `referencedBy`.
Например, обе сущности `user` и `userInfo` имеют строковый столбец `username` и необходимо установить связь через него.
Тогда их спецификации будут выглядеть так:
```yaml
# user
metadata:
  name: user
spec:
  attributes:
    userInfo:
      type: relation
      relType: oneToOne
      target: userInfo
      columnName: username
      referencedBy: username
```

```yaml
# userInfo
metadata:
  name: userInfo
spec:
  attributes:
    username:
      type: string
      columnName: username
      unique: true
      length: 50
```

Связь `onToOne` может быть и двусторонней.
Тогда вторая сущность также содержит виртуальную ссылку на текущую (без физического столбца таблицы, т.к. не является "владельцем" связи) с дополнительным параметром `mappedBy`.
Этот параметр содержит имя атрибута сущности-владельца, по которому построена связь:
```yaml
# userInfo
metadata:
  name: userInfo
spec:
  attributes:
    user:
      type: relation
      relType: oneToOne
      target: user
      mappedBy: userInfo
```

При двусторонней связи сущность-владелец также должна содержать дополнительный параметр (называется `inversedBy`) на своей стороне.
Аналогично `mappedBy`, этот параметр содержит имя атрибута противоположной сущности, по которому построена связь:
```yaml
# user
metadata:
  name: user
spec:
  attributes:
    userInfo:
      type: relation
      relType: oneToOne
      target: userInfo
      inversedBy: user
```

#### Связь manyToOne

Связь `manyToOne` подразумевает, что в другой таблице существует запись, на которую ссылаются записи текущей сущности.
Связь `manyToOne` всегда является "владеющей", т.е. хранит в столбце своего атрибута идентификатор записи второй сущности.
Сущности составляющие связь `manyToOne` и `oneToMany`, могут принадлежать разным источникам данных. Определение связи `manyToOne`:
```yaml
# book
metadata:
  name: book
spec:
  attributes:
    userInfo:
      type: relation
      relType: manyToOne
      target: category
      columnName: category_id
```

Также, аналогично `oneToOne`, можно переопределить идентификатор противоположной сущности, если добавить к атрибуту связи поле `referencedBy`.

#### Связь oneToMany

Связь `manyToOne` можно сделать двусторонней.
Тогда вторая сущность будет содержать виртуальную ссылку типа `oneToMany` на список записей текущей сущности с дополнительным параметром `mappedBy`.
Этот параметр содержит имя атрибута сущности-владельца, по которому построена связь `manyToOne`:
```yaml
# category
metadata:
  name: category
spec:
  attributes:
    books:
      type: relation
      relType: oneToMany
      target: book
      mappedBy: category
```

При двусторонней связи сущность-владелец также должна содержать дополнительный параметр (называется `inversedBy`) на своей стороне.
Аналогично `mappedBy`, этот параметр содержит имя атрибута противоположной сущности, по которому построена связь `oneToMany`:
```yaml
# book
metadata:
  name: book
spec:
  attributes:
    userInfo:
      type: relation
      relType: manyToOne
      target: category
      columnName: category_id
      inversedBy: books
```

#### Связь manyToMany

Связь `manyToMany` подразумевает, что на записи текущей сущности могут ссылаться записи второй сущности.
Обратное также верно: на записи второй сущности могут ссылаться записи текущей сущности.
Для моделирования такой связи в реляционной СУБД необходимо наличие промежуточной таблицы, в которой хранятся ссылки таблиц первой и второй сущностей друг на друга.
Исходя из этого требования, перед реализацией связи `manyToMany` нужно создать промежуточную сущность с двумя атрибутами `source` и `target` типа `relation` и значением `relType` = `manyToOne` (по одному для каждой из основных сущностей):
```yaml
# categoryBookMap
metadata:
  name: categoryBookMap
spec:
  attributes:
    source:
      type: relation
      relType: manyToOne
      target: category
      columnName: category_id
    target:
      type: relation
      relType: manyToOne
      target: book
      columnName: book_id
```

После этого можно создать связи `manyToMany` в каждой из основных сущностей, указав промежуточную связь в свойстве `intermediate` атрибута связи.
Если текущая сущность находится в `categoryBookMap` в позиции `source`, то имя атрибута противоположной сущности указывается в свойстве `inversedBy`, если в позиции `target` - то в свойстве `mappedBy`:
```yaml
# category
metadata:
  name: category
spec:
  attributes:
    books:
      type: relation
      relType: manyToMany
      target: book
      intermediate: categoryBookMap
      inversedBy: categories
```

```yaml
# book
metadata:
  name: book
spec:
  attributes:
    categories:
      type: relation
      relType: manyToMany
      target: category
      intermediate: categoryBookMap
      mappedBy: books
```

Сущности составляющие связь `manyToMany`, не могут принадлежать разным источникам данных. Это ограничение обусловлено наличием промежуточной сущности.

После того как файл с определением сущности создан, его необходимо поместить в каталог [schema](/src/main/resources/schema) (или в любой из его подкаталогов) и перезапустить приложение.
При запуске система просканирует все изменения в каталоге и применит из к текущей схеме данных.
В результате будет создана сущность и соответствующие объекты в базе данных.
Аналогично, при изменении файла последующий запуск приложения также повлечет необходимые изменения.
Кроме YAML определение сущности может быть создано в JSON-формате ([пример](/src/main/resources/schema/example-item.json)).

**Второй способ** создания (изменения) сущности - использование метода `POST /api/model/apply`. В теле нужно передать определение сущности в JSON-формате.

Спецификация OpenAPI по REST методам доступна через запущенное приложение на странице `/swagger-ui.html`.

Для использования **третьего способа** создания (изменения) сущностей необходимо сначала рассмотреть операции над сущностями.

## Операции

Для каждой сущности система генерирует необходимый для нее набор операций в соответствии с ее именем.
Ниже в качестве примера приведены операции для сущности `book`. Первые две операции в схеме GraphQL имеют тип `query`, остальные - `mutation`.
- `books` - возвращает список записей;
- `book` - возвращает конкретную запись;
- `createBook` - создание записи;
- `createBookVersion` - создание новой версии записи для сущностей с флагом `versioned` (см. ниже);
- `createBookLocalization` - создание новой локализации записи для сущностей с флагом `localized` (см. ниже);
- `updateBook` - изменение записи;
- `deleteBook` - удаление записи;
- `purgeBook` - удаление всех версий записи;
- `lockBook` - блокировка записи для сущности без флага `notLockable`;
- `unlockBook` - разблокировка записи для сущности без флага `notLockable`;
- `promoteBook` - перемещение записи на следующий этап жизненного цикла (см. раздел [Жизненный цикл сущностей](lifecycle.md)).

Сущности "только для чтения" имеют только первые два метода.

Кроме перечисленных методов сущность может содержать произвольные кастомные методы. Подробнее о них см. в разделе [Жизненный цикл сущностей](lifecycle.md).

Рассмотрим примеры основных операции над записями сущности.
На запущенном приложении можно воспользоваться встроенной версией Graph*i*QL по адресу `/graphiql` (перед выполнением запроса нужно в поле с заголовками добавить заголовок `Authorization` с полученным токеном - см. раздел [Безопасность](security.md)).
Можно также использовать любой UI инструмент, поддерживающий работу с GraphQL ([Postman](https://www.postman.com), [Insomnia](https://insomnia.rest) и т.д.).

### Создание

Пример запроса GraphQL:
```
mutation {
  createBook(
    data: {
      name: "Alice's Adventures in Wonderland"
      rating: 8
    }
  ) {
    data {
      id
      name
      rating
      permission {
        data {
          name
        }
      }
    }
  }
}
```

Ответ будет содержать данные созданной записи:

```json
{
  "data": {
    "createBook": {
      "data": {
        "id": "d160cdfd-e548-412f-9249-d27de0274499",
        "name": "Alice's Adventures in Wonderland",
        "rating": 9,
        "permission": {
          "data": {
            "name": "Default Permission"
          }
        }
      }
    }
  }
}
```

### Изменение

Пример запроса GraphQL:
```
mutation {
  updateBook(
    id: "d160cdfd-e548-412f-9249-d27de0274499"
    data: {
        rating: 9
    }
  ) {
    data {
      id
      name
      rating
    }
  }
}
```

### Удаление

```
mutation {
  deleteBook(
    id: "d160cdfd-e548-412f-9249-d27de0274499"
    deletingStrategy: NO_ACTION
  ) {
    data {
      id
      name
      rating
    }
  }
}
```

При удалении необходимо кроме идентификатора записи необходимо передать параметр `deletionStrategy`.
Этот параметр определяет действие, которое будет выполняться со связанными сущностями и принимает три возможных значения:
- `NO_ACTION` - не предпринимать никаких действий;
- `SET_NULL` - установить в столбце связанной сущности значение `NULL`;
- `CASCADE` - каскадное удаление связанных сущностей.

### Получение данных сущности

Пример запроса GraphQL:
```
query {
  book(
      id: "d160cdfd-e548-412f-9249-d27de0274499"
  ) {
    data {
      id
      name
      rating
    }
  }
}
```

### Поиск и фильтрация

Пример запроса GraphQL:
```
query {	
  books(
    filters: {
      name: {
        containsi: "alice"
        notContainsi: "jane"
      }
      rating: {
        gte: 8
      }
      or: {
        updatedBy: {
          username: {
            eq: "root"
          }
        }
      }
    }
    sort: ["name:asc"]
    pagination: {
      page: 1
      pageSize: 20
    }
  ) {
    data {
      id
      name
      rating
      permission {
        data {
          name
        }
      }
    }
    meta {
      pagination {
        page
        pageSize
        pageCount
        total
      }
    }
  }
}
```

Блок `filters` может содержать гибко настраиваемые условия фильтрации (унифицированы с фильтрами, применяемыми в [Strapi](https://strapi.io)) с поддержкой вложенности атрибутов.
Полный перечень операторов следующий (для разных типов атрибутов может различаться):
- `eq` - равно;
- `ne` - не равно;
- `gt` - больше;
- `gte` - больше или равно;
- `lt` - меньше;
- `lte` - меньше или равно;
- `contains` - содержит подстроку;
- `containsi` - содержит подстроку (без учета регистра);
- `notContains` - не содержит подстроку;
- `notContainsi` - не содержит подстроку (без учета регистра);
- `startsWith` - начинается с подстроки;
- `endsWith` - заканчивается подстрокой;
- `between` - между (операнд должен быть массивом из двух элементов);
- `in` - входит в (операнд должен быть массивом);
- `notIn` - не входит в (операнд должен быть массивом);
- `null` - равно `NULL` (операнд должен быть логическим значением `true` или `false`);
- `notNull` - не равно `NULL` (операнд должен быть логическим значением `true` или `false`).

Условия фильтрации могут комбинироваться операторами `and`, `or` и `not`.

В поле `sort` передается список полей сортировки.
После имени через двоеточие может задаваться направление сортировки (`asc` - по возрастанию или `desc` - по убыванию).
По умолчанию сортировка выполняется по возрастанию.

Блок `pagination` служит для настройки постраничного вывода и может содержать поля `page`, `pageSize` (номер начиная с 1 и размер страницы) либо `start`, `limit` (номер первой записи начиная с 0 и число записей).
В ответе в блоке `meta.pagination` кроме перечисленных параметров (`page`, `pageSize`, `start`, `limit`) можно запросить поля `total` (общее число записей, соответствующих условию фильтрации) и `totalPages` (общее число страниц).

Пример ответа:
```json
{
  "data": {
    "books": {
      "data": [
        {
          "id": "d160cdfd-e548-412f-9249-d27de0274499",
          "name": "Alice's Adventures in Wonderland",
          "rating": 9,
          "permission": {
            "data": {
              "name": "Default Permission"
            }
          }
        }
      ],
      "meta": {
        "pagination": {
          "page": 1,
          "pageCount": 1,
          "total": 1
        }
      }
    }
  }
}
```

Если сущность кэшируемая, но размер данных превышает параметр конфигурации приложения `scicms-core.data.max-cached-records-size` (по умолчанию - 200), то данные не будут кэшироваться.

После описания основных операций можно рассмотреть **третий способ** создания/изменения/удаления сущностей.
Описание (метаданные, атрибуты, индексы и пр.) любой сущности - это такая же сущность (с именем `item`, она хранится в основной БД наряду с другими сущностями в таблице `core_items`).
Таким образом для манипуляции сущностями предназначены методы `createItem`, `updateItem` и `deleteItem`.
Они повсеместно используются в клиентском приложении [SciCMS Client](https://github.com/borisblack/scicms-client).
Структура тела запроса практически идентична REST методу `POST /api/model/apply` за исключением того, что содержимое `metadata` указывается непосредственно в поле `data`.
После выполнения изменения схема GraphQL автоматически генерируется заново и клиент может работать с актуальной версией.
Если несколько экземпляров SciCMS работают в облачном окружении, они синхронизируются через кэш Redis и каждый из них также содержит последнюю версию схемы.

## Версионирование

Для того чтобы сущность была версионной, необходимо задать ей параметр `metadata.versioned` равным `true`.
В этом случае при генерации GraphQL API она получит новые методы `createVersion` (создать новую версию записи) и `purge` (удалить все версии записи).
Метод `createVersion` может принимать дополнительный параметр `copyCollectionRelations`.
Если он передан в значении `true`, то будут созданы копии записей в связанных таблицах для атрибутов `oneToMany` и `manyToMany`.
Версионные сущности не имеют метода `update`, т.е. записи не обновляются (всегда создаются новые версии).

За присвоение версий отвечает атрибут `majorRev`.
Он может задаваться автоматически, либо вручную (если у сущности выставлен параметр `metadata.manualVersioning`).
При автоматической нумерации за присвоение следующей версии отвечает так называемая версионная политика.
Это отдельная сущность `revisionPolicy` (ее записи хранятся в таблице `core_revision_policies`), которая для каждой политики имеет текстовое поле `revisions`, определяющая состав и порядок версий.

При ручном присвоении в запрос добавляется обязательный параметр `majorRev`.
Также у каждой версионируемой записи имеется атрибут `minorRev`, он опциональный и может устанавливаться пользователем самостоятельно в блоке `data` запроса.
Пример запроса на создание новой версии (обязательно передается идентификатор исходной записи):
```
mutation {
  createBookVersion(
    id: "d160cdfd-e548-412f-9249-d27de0274499"
    majorRev: "A"
    data: {
      name: "Alice's Adventures in Wonderland"
      rating: 9
      minorRev: "0"
    }
  ) {
    data {
      id
      name
      rating
    }
  }
}
```

В запросе поиска у версионных сущностей добавляется атрибут `majorRev`.

## Локализация

Для того чтобы сущность была мультиязычной, необходимо задать ей параметр `metadata.localized` равным `true`.
В этом случае при генерации GraphQL API она получит новый метод `createLocalization` с параметром `locale`.
Передаваемое значение локали должно соответствовать атрибуту `name` существующей записи одноименной сущности `locale` (ее записи хранятся в таблице `core_locales`).
Пример запроса на создание новой локализации (обязательно передается идентификатор исходной записи):
```
mutation {
  createBookLocalization(
    id: "d160cdfd-e548-412f-9249-d27de0274499"
    locale: "ru"
    data: {
      name: "Алиса в Стране Чудес"
      rating: 9
    }
  ) {
    data {
      id
      name
      rating
    }
  }
}
```

В запросе поиска у мультиязычных сущностей добавляется атрибут `locale`.

## Источники данных

Как и любая другая сущность, источник данных создается GraphQL-запросом:
```
mutation {
  createDatasource(
    data: {
      name: "acc"
      connectionString: "jdbc:postgresql://127.0.0.1:5432/accounting"
      username: "${ACC_DB_USERNAME}"
      password: "${ACC_DB_PASSWORD}"
    }
  ) {
    data {
      id
      name
    }
  }
}
```

Имя пользователя и пароль БД можно указать напрямую, либо используя переменные окружения (как в примере).
Несмотря на то, что пароль не может быть прочитан через внешний API, в БД SciCMS учетные данные источников данных хранятся в чистом виде (т.к. используются при открытии подключений).
Поэтому рекомендуется использовать именно второй способ (переменные окружения).
После создания, источник данных может быть использован в определении любой сущности по его имени.

Весь описанный API также используется в клиентском приложении [SciCMS Client](https://github.com/borisblack/scicms-client), которое предоставляет удобный пользовательский интерфейс для управления сущностями, а также многие другие функции.
