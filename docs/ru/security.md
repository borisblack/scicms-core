# Безопасность

## Аутентификация для взаимодействия с API

### Локальная аутентификация

Получение токена выполняется через запрос `POST /api/auth/local` с телом:
```json
{
  "username": "root", 
  "password": "master"
}
```

Учетная запись пользователя `root` с паролем `master` создается при первом запуске системы с полным набором прав.
Тело ответа содержит JWT токен и другую информацию о пользователе:
```json
{
  "jwt": "eyJhbGciOiJIUzUxMiJ9.eyJqdGkiOiJzY2lzb2x1dGlvbnNKV1QiLCJzdWIiOiJyb290IiwiYXV0aG9yaXRpZXMiOlsiUk9MRV9BRE1J...", 
  "user": {
    "id": "0c924266-3c61-4362-81d7-9d69403fbe32",
    "username": "root",
    "roles": [
      "ROLE_ADMIN"
    ],
    "authType": "LOCAL"
  },
  "expirationIntervalMillis": 86400000
}
```

**Во всех последующих запросах** полученный токен должен присутствовать в заголовке `Authorization`: `Authorization: Bearer <jwt>`.

### Аутентификация по протоколу OAuth2

Для настройки OAuth2 необходимо в файле [application.yml](/src/main/resources/application.yml) прописать параметры провайдера
в блоке `scicms-core.security.oauth2-providers`:
```yaml
scicms-core:
  security:
    oauth2-providers:
      - id: my_provider
        name: My Provider
        auth-url: https://my-provider.example.com/auth
        access-token-url: https://my-provider.example.com/token
        api-url: https://my-provider.example.com
        client-id: <my_client_id>
        client-secret: <my_client_secret>
```

Здесь:
- `id` - произвольный идентификатор провайдера (латиницей без пробелов);
- `name` - произвольное имя провайдера;
- `auth-url` - адрес страницы аутентификации провайдера (используется клиентским приложением);
- `access-token-url` - адрес для получения токена доступа (access token) по коду доступа (access code), полученному от провайдера;
- `api-url` - адрес для получения имени пользователя от провайдера по токену доступа;
- `client-id` - ID клиентского приложения (выдается провайдером при регистрации приложения);
- `client-secret` - пароль клиенского приложения (также выдается провайдером при регистрации приложения).

После сохранения параметров и перезапуска приложения можно выполнять вход. Для этого нужно получить код доступа
(access code) у провайдера по адресу, указанному в параметре `auth-url` с последующей переадресацией и передачей кода
доступа в качестве дополнительного параметра в строке URL. Эта процедура, как и последующие шаги уже реализованы в
клиентском приложении [SciCMS Client](https://github.com/borisblack/scicms-client).
После получения кода доступа можно выполнять вход в SciCMS Core методом `POST /api/auth/oauth2`:
```json
{
  "provider": "my_provider",
  "code": "<access_code>"
}
```

Здесь `provider` - идентификатор провайдера, указанный ранее в параметрах, `code` - код доступа, полученный от провайдера.
Тело ответа аналогично локальной аутентификации и содержит JWT токен и другую информацию о пользователе. Полученный
токен должен присутствовать во всех последующих запросах в заголовке `Authorization`: `Authorization: Bearer <jwt>`.

## Управление пользователями

### Изменение пароля

После первого входа пароль может быть изменен методом `POST /api/auth/local/password`:
```json
{
  "oldPassword": "<old_password>",
  "newPassword": "<new_password>"
}
```

### Регистрация нового пользователя

При необходимости можно зарегистрировать нового пользователя, для этого нужно выполнить запрос `POST /api/auth/local/register`:
```json
{
  "username": "<username>",
  "password": "<password>"
}
```

Пароли пользователя сохранятся в БД в зашифрованном виде, их невозможно получить через внешний API.

### Создание нового пользователя от имени администратора

В общем случае создание нового пользователя выполняется через GraphQL API (на эндпоинт `/graphql`):
```
mutation {
  createUser(
    data: {
      username: "my_user"
      password: "my_password"
      enabled: true
    }
  ) {
    data {
        id
    }
  }
}
```

## Роли и группы

Роли могут назначаться как непосредственно пользователю, так и группе.

### Создание роли

Для назначения роли пользователю необходимо выполнить следующий GraphQL-запрос. Здесь в поле `user` передается имя
пользователя. По соглашению имя роли пишется латиницей прописными буквами с префиксом `ROLE_`.
```
mutation {
  createRole(
    data: {
      user: "my_user"
      role: "ROLE_MANAGER"
    }
  ) {
    data {
      id
    }
  }
}
```

Для удобства управления доступом рекомендуется создавать группы пользователей (соответствующие их функциональным
обязанностям) и назначать роли этим группам.

### Создание группы

Запрос на создание группы пользователей:
```
mutation {
  createGroup(
    data: {
      groupName: "Managers"
    }
  ) {
    data {
      id
    }
  }
}
```

В ответе придет идентификатор созданной группы:
```json
{
  "data": {
    "createGroup": {
      "data": {
        "id": "74ed97ab-8443-4ff7-8b1f-e455c243e0d0"
      }
    }
  }
}
```

### Создание роли группы

Для назначения роли вновь созданной группе группе необходимо выполнить GraphQL-запрос, передав в поле `group`
идентификатор из предыдущего ответа:
```
mutation {
  createGroupRole(
    data: {
      group: "74ed97ab-8443-4ff7-8b1f-e455c243e0d0"
      role: "ROLE_MANAGER"
    }
  ) {
    data {
      id
    }
  }
}
```

### Добавление пользователя в группу

Запрос для включения пользователя в группу (обратите внимание, что здесь в поле `user` передается имя пользователя):
```
mutation {
  createGroupMember(
    data: {
      group: "74ed97ab-8443-4ff7-8b1f-e455c243e0d0"
      user: "my_user"
    }
  ) {
    data {
      id
    }
  }
}
```

Таким образом после добавления пользователя в группу `Managers` он автоматически получит все роли, присвоенные этой
группе (в данном случае одну роль - `ROLE_MANAGER`).

Упрощенная схема данных (без служебных атрибутов) для перечисленных выше сущностей выглядит следующим образом:

![Схема данных для управления пользователями и группами](/docs/img/sec_db_users_groups.png "Схема данных для управления пользователями и группами")

## Разрешения и доступы

После создания пользователей и назначения им необходимых ролей, можно назначать им доступы. Механизм контроля доступа
в SciCMS Core основан на понятии "разрешение" ("permission"). Каждая сущность имеет атрибут `permission` (столбец
`permission_id` таблицы сущности) типа `relation`, который ссылается на одноименную сущность `permission` (таблица
`sec_permissions` в основном источнике данных). Более подробно о сущностях и атрибутах см. в разделе
[Модель данных](data_model.md).

Связь между пользователем/ролью и разрешением осуществляется через сущность `access` (таблица `sec_access` в основном
источнике данных), которая имеет следующие атрибуты:
- `source`, тип `relation` - ссылка на разрешение;
- `target`, тип `relation` -ссылка на пользователя/роль (через промежуточную сущность `identity` - субъект безопасности);
- `label`, тип `string` - произвольное название доступа;
- `beginDate`, тип `datetime` - дата начала действия доступа;
- `endDate`, тип `datetime` - дата окончания действия доступа (если не указана, то доступ бессрочный);
- `mask`, тип `int` - маска доступа, представляющая собой целое число от 0 до 31 (5 разрядов двоичного числа). Каждый
  бит числа означает тип доступа из множества {`A` - Administration, `D` - Delete, `C` - Create, `W` - Write, `R` - Read}
  слева направо в порядке перечисления;
- `granting`, тип `bool` - флаг, определяющий, является ли разрешение дающим доступ или, наоборот, запрещающим доступ.
  Запрещающий доступ имеет более высокий приоритет, чем разрешающий.

Флаг доступа `A` позволяет изменять значение атрибута `permission` сущности. При этом выбранное разрешение должно входить
в список доступных разрешений для сущности. Кроме этого, для каждой сущности может быть задано разрешение по умолчанию,
используемое для всех новых записей данного типа. Если разрешение по умолчанию не задано, то будет использовано
глобальное разрешение по умолчанию `Default Permission`. Подробнее о доступных разрешениях см. в разделе
[Модель данных](data_model.md).

## Предоставление доступа пользователю/группе к записи

С учетом описанной выше модели, процесс предоставления доступа выглядит следующим образом.

### 1. Создать разрешение (если оно еще не создано) через API GraphQL

```
mutation {
  createPermission(
    data: {
      name: "My Permission"
    }
  ) {
    data {
      id
    }
  }
}
```

В ответе придет идентификатор созданного разрешения:
```json
{
  "data": {
    "createPermission": {
      "data": {
        "id": "d7c7ea80-2aa1-4592-983e-cbe3af03591c"
      }
    }
  }
}
```

### 2. Создать субъект безопасности - identity (если еще не создан)

В запросе в поле `name` должно быть имя роли или существующего пользователя. Если передается имя пользователя, то флаг
`principal` должен иметь значение `true`. В случае, если передано имя роли - `false`.

```
mutation {
  createIdentity(
    data: {
      name: "my_user"
      principal: true
    }
  ) {
    data {
      id
    }
  }
}
```

В ответе придет идентификатор созданного субъекта:
```json
{
  "data": {
    "createIdentity": {
      "data": {
        "id": "208c588e-9e9e-4654-bd3b-debd52892596"
      }
    }
  }
}
```

### 3. Добавить доступ

В запросе в полях `source` и `target` должны быть идентификаторы созданных ранее разрешения и субъекта соответственно.
```
mutation {
  createAccess(
    data: {
      label: "My Access"
      source: "d7c7ea80-2aa1-4592-983e-cbe3af03591c"
      target: "208c588e-9e9e-4654-bd3b-debd52892596"
      mask: 3
      beginDate: "2024-06-16T00:00:00Z"
      granting: true
    }
  ) {
    data {
      id
    }
  }
}
```

В поле `mask` передано число `3`, что в двоичной арифметике соответствует `00011`, или операциям записи и чтения
(см. выше).

Упрощенная схема данных контроля доступа (без служебных атрибутов) для перечисленных сущностей выглядит так:
![Схема данных для управления доступом](/docs/img/sec_db_acl.png "Схема данных для управления доступом")

Для достижения наибольшей гибкости управления доступом рекомендуется использовать роли групп и назначать отдельные
разрешения для каждой (небольшой) функциональной подсистемы (например, отдел расчета, клиентские менеджеры, менеджеры
продаж, руководство и т.д.). Тогда для каждой роли мы сможем добавлять разрешения с необходимым доступом. Чем меньше
функциональная подсистема, тем гибче и детальнее выполняется настройка доступа.

Аналогично любым другим сущностям в SciCMS Core, все перечисленные примитивы безопасности (пользователи, роли, группы, роли
групп, члены групп, разрешения, субъекты, доступы) имеют соответствующие операции чтения, изменения и удаления.
Подробнее об операциях см. в разделе [Модель данных](data_model.md).

Весь описанный API также используется в клиентском приложении [SciCMS Client](https://github.com/borisblack/scicms-client),
которое предоставляет удобный пользовательский интерфейс для управления доступом, а также многие другие функции.
